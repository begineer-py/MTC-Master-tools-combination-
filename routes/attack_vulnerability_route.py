from flask import Blueprint, request, jsonify, redirect, url_for, render_template, current_app
from vulnerability_scanning.threads.thread_sql import SQLInjectionThread
from utils.decorators import login_required
from utils.permission import check_user_permission 
import queue
import logging
from instance.models import Target, if_sql_injection, db, crawler_each_url

# 设置日志
logger = logging.getLogger(__name__)

attack_vulnerability_route = Blueprint('attack_vulnerability_route', __name__)

@attack_vulnerability_route.route('/attack/vulnerability/<int:target_id>', methods=['GET'])
@login_required
def attack_vulnerability(target_id):
    """漏洞攻击页面"""
    # 检查权限
    target = check_user_permission(target_id=target_id)
    if not isinstance(target, Target):
        return target  # 返回错误响应
    
    # 从数据库获取URL列表
    urls = crawler_each_url.query.filter_by(target_id=target_id).all()
    url_data = []
    
    for url in urls:
        url_data.append({
            'id': url.id,
            'url': url.url,
            'status_code': url.status_code,
            'content_type': url.content_type
        })
    
    # 渲染模板
    return render_template(
        'vulnerability/vulnerability_start.html',
        target_id=target_id,
        urls=url_data,
        target=target
    )

@attack_vulnerability_route.route('/attack/vulnerability/<int:target_id>/scan', methods=['POST'])
@login_required
def attack_vulnerability_scan(target_id):
    """开始漏洞扫描"""
    # 检查权限
    target = check_user_permission(target_id=target_id)
    if not isinstance(target, Target):
        return target  # 返回错误响应
    
    # 获取要扫描的URL ID
    data = request.get_json()
    if not data or 'url_id' not in data:
        return jsonify({
            'success': False,
            'message': '缺少URL ID参数'
        }), 400
    
    url_id = data['url_id']
    
    # 检查URL是否存在
    url = crawler_each_url.query.filter_by(id=url_id, target_id=target_id).first()
    if not url:
        return jsonify({
            'success': False,
            'message': '指定的URL不存在或不属于该目标'
        }), 404
    
    # TODO: 实现实际的漏洞扫描逻辑
    
    # 返回成功响应
    return jsonify({
        'success': True,
        'message': '漏洞扫描已启动',
        'url_id': url_id,
        'url': url.url
    })

@attack_vulnerability_route.route('/attack/vulnerability/<int:target_id>/result', methods=['GET'])
@login_required
def attack_vulnerability_result(target_id):
    """获取漏洞扫描结果"""
    # 检查权限
    target = check_user_permission(target_id=target_id)
    if not isinstance(target, Target):
        return target  # 返回错误响应
    
    # 获取URL ID
    url_id = request.args.get('url_id')
    if not url_id:
        return jsonify({
            'success': False,
            'message': '缺少URL ID参数'
        }), 400
    
    # 检查URL是否存在
    url = crawler_each_url.query.filter_by(id=url_id, target_id=target_id).first()
    if not url:
        return jsonify({
            'success': False,
            'message': '指定的URL不存在或不属于该目标'
        }), 404
    
    # TODO: 从数据库获取实际的漏洞扫描结果
    
    # 返回模拟的扫描结果
    return jsonify({
        'success': True,
        'url': url.url,
        'vulnerabilities': []  # 这里返回空列表，实际使用时应该返回真正的漏洞数据
    })

@attack_vulnerability_route.route('/api/<int:target_id>/vulnerability/sql-injection/scan', methods=['POST'])
@login_required
def sql_injection_scan(target_id):
    try:
        # 检查权限
        target = check_user_permission(target_id=target_id)
        current_app.logger.info(f"检查用户权限: {target}")
        if not isinstance(target, Target):
            current_app.logger.error(f"用户权限检查失败: {target}")
            return redirect(url_for('index.login', next=request.url))
            
        if not target_id:
            return jsonify({
                'status': 'error',
                'message': '目标ID不能为空'
            }), 400
            
        # 获取目标信息
        target = Target.query.get(target_id)
        if not target:
            return jsonify({
                'status': 'error',
                'message': '目标不存在'
            }), 404
            
        target_url = target.target_ip
        current_app.logger.info(f"开始对目标 {target_url} 进行 SQL 注入扫描")
        
        # 创建并启动扫描线程
        scan_thread = SQLInjectionThread(
            target_id=target_id,
            target_url=target_url,
            app=current_app,
            num_threads=10  # 可以根据需要调整线程数
        )
        scan_thread.start()
        
        # 等待结果（最多等待300秒）
        try:
            scan_result, success, code = scan_thread.get_result(timeout=300)
            if not success:
                error_message = scan_result.get('message', '未知错误')
                current_app.logger.error(f"扫描失败: {error_message}")
                return jsonify({
                    'status': 'error',
                    'message': error_message,
                    'code': code
                }), code
            
            return jsonify({
                'status': 'success',
                'message': '扫描完成',
                'result': scan_result,
                'code': code
            }), code
            
        except queue.Empty:
            current_app.logger.error("扫描超时")
            return jsonify({
                'status': 'error',
                'message': '扫描超时，请稍后重试',
                'code': 408
            }), 408
            
    except Exception as e:
        error_msg = str(e)
        current_app.logger.error(f"SQL injection scan error: {error_msg}")
        return jsonify({
            'status': 'error',
            'message': f'扫描过程中发生错误: {error_msg}',
            'code': 500
        }), 500

@attack_vulnerability_route.route('/desktop/<int:target_id>', methods=['GET'])
@login_required
def vulnerability_start(target_id):
    try:
        # 检查权限
        target = check_user_permission(target_id=target_id)
        if not target:
            return jsonify({'status': 'error', 'message': '无权访问该目标'}), 403
        if not isinstance(target, Target):
            return redirect(url_for('index.login'))
            
        # 获取最新的扫描结果
        latest_result = if_sql_injection.query.filter_by(
            target_id=target_id
        ).order_by(
            if_sql_injection.scan_time.desc()
        ).first()
        
        return render_template(
            'vulnerability_start.html',
            target=target,
            latest_result=latest_result
        )
        
    except Exception as e:
        current_app.logger.error(f"访问漏洞扫描页面时出错: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': f'页面加载失败: {str(e)}'
        }), 500