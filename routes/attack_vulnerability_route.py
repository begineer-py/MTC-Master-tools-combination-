from flask import Blueprint, request, jsonify, redirect, url_for, render_template, current_app
from vulnerability_scanning.threads.thread_sql import SQLInjectionThread
from flask_login import login_required, current_user
from utils.permission import check_user_permission 
import queue
from instance.models import Target, if_sql_injection

attack_vulnerability_route = Blueprint('attack_vulnerability_route', __name__)

@attack_vulnerability_route.route('/api/<int:user_id>/<int:target_id>/vulnerability/sql-injection/scan', methods=['POST'])
@login_required
def sql_injection_scan(user_id, target_id):
    try:
        # 檢查用戶權限
        permission_result = check_user_permission(user_id, target_id)
        current_app.logger.info(f"檢查用戶權限: {permission_result}")
        if not isinstance(permission_result, Target):
            current_app.logger.error(f"用戶權限檢查失敗: {permission_result}")
            return redirect(url_for('index.login', next=request.url))
            
        if not target_id or not user_id:
            return jsonify({
                'status': 'error',
                'message': '目標ID和用戶ID不能為空'
            }), 400
            
        # 獲取目標信息
        target = Target.query.get(target_id)
        if not target:
            return jsonify({
                'status': 'error',
                'message': '目標不存在'
            }), 404
            
        target_url = target.target_ip
        current_app.logger.info(f"開始對目標 {target_url} 進行 SQL 注入掃描")
        
        # 創建並啟動掃描線程
        scan_thread = SQLInjectionThread(
            target_id=target_id,
            target_url=target_url,
            app=current_app,
            num_threads=10  # 可以根據需要調整線程數
        )
        scan_thread.start()
        
        # 等待結果（最多等待300秒）
        try:
            scan_result, success, code = scan_thread.get_result(timeout=300)
            if not success:
                error_message = scan_result.get('message', '未知錯誤')
                current_app.logger.error(f"掃描失敗: {error_message}")
                return jsonify({
                    'status': 'error',
                    'message': error_message,
                    'code': code
                }), code
            
            return jsonify({
                'status': 'success',
                'message': '掃描完成',
                'result': scan_result,
                'code': code
            }), code
            
        except queue.Empty:
            current_app.logger.error("掃描超時")
            return jsonify({
                'status': 'error',
                'message': '掃描超時，請稍後重試',
                'code': 408
            }), 408
            
    except Exception as e:
        error_msg = str(e)
        current_app.logger.error(f"SQL injection scan error: {error_msg}")
        return jsonify({
            'status': 'error',
            'message': f'掃描過程中發生錯誤: {error_msg}',
            'code': 500
        }), 500

@attack_vulnerability_route.route('/<int:user_id>/desktop/<int:target_id>', methods=['GET'])
@login_required
def vulnerability_start(user_id, target_id):
    try:
        # 檢查用戶權限
        target = check_user_permission(current_user.id, target_id)
        if not target:
            return jsonify({'status': 'error', 'message': '無權訪問該目標'}), 403
        if not isinstance(target, Target):
            return redirect(url_for('index.login'))
            
        # 獲取最新的掃描結果
        latest_result = if_sql_injection.query.filter_by(
            target_id=target_id
        ).order_by(
            if_sql_injection.scan_time.desc()
        ).first()
        
        return render_template(
            'vulnerability_start.html',
            target=target,
            latest_result=latest_result
        )
        
    except Exception as e:
        current_app.logger.error(f"訪問漏洞掃描頁面時出錯: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': f'頁面載入失敗: {str(e)}'
        }), 500