import threading
import queue
from flask import current_app
from vulnerability_scanning.sql_injection import SQLInjectionScanner
from datetime import datetime

class SQLInjectionThread(threading.Thread):
    """SQL 注入掃描線程類"""
    
    def __init__(self, target_id, target_url, app=None, num_threads=5):
        """
        初始化 SQL 注入掃描線程
        
        Args:
            target_id: 目標 ID
            target_url: 目標 URL
            app: Flask 應用實例
            num_threads: 工作線程數量
        """
        super().__init__()
        self.target_id = target_id
        self.target_url = target_url
        self.app = app._get_current_object() if hasattr(app, '_get_current_object') else app
        self.num_threads = num_threads
        self.result_queue = queue.Queue()
        self.daemon = True
        
    def run(self):
        """線程執行方法"""
        try:
            # 創建應用上下文
            if self.app:
                ctx = self.app.app_context()
                ctx.push()
            
            try:
                # 創建掃描器實例
                scanner = SQLInjectionScanner(
                    target_id=self.target_id,
                    target_url=self.target_url,
                    num_threads=self.num_threads
                )
                
                # 執行掃描
                result = scanner.scan()
                self.result_queue.put((result, True, 200))
                
            except Exception as e:
                error_msg = f"SQL 注入掃描出錯: {str(e)}"
                self.app.logger.error(error_msg)
                self.result_queue.put(({'message': error_msg}, False, 500))
                
            finally:
                # 確保在完成後移除上下文
                if self.app:
                    ctx.pop()
                    
        except Exception as e:
            error_msg = f"線程執行出錯: {str(e)}"
            if self.app:
                self.app.logger.error(error_msg)
            self.result_queue.put(({'message': error_msg}, False, 500))

    def get_result(self, timeout=300):
        """
        獲取掃描結果
        
        Args:
            timeout: 超時時間（秒）
            
        Returns:
            tuple: (result, success, code)
        """
        try:
            result, success, code = self.result_queue.get(timeout=timeout)
            return result, success, code
        except queue.Empty:
            return {'message': '掃描超時'}, False, 408
        except Exception as e:
            return {'message': f'獲取結果時出錯: {str(e)}'}, False, 500
