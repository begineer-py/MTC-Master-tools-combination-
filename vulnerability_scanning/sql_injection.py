import subprocess
import os 
import logging
import re
import json
import tempfile
from datetime import datetime
import time
from sqlalchemy.exc import OperationalError
from threading import Lock
from contextlib import contextmanager
from instance.models import db,if_sql_injection,crawler_each_url,crawler_each_form
from flask import current_app, jsonify
import sys
import requests
from urllib.parse import urlparse, parse_qs, urlencode
import queue
import threading

class SQLInjectionScanner:
    def __init__(self, target_id, target_url, num_threads=5):
        """初始化掃描器"""
        self.target_id = target_id
        self.target_url = target_url
        self.num_threads = num_threads
        self.app = current_app._get_current_object()
        self.python_path = sys.executable
        # 使用相對路徑
        base_dir = os.path.abspath(os.path.dirname(__file__))
        self.sqlmap_path = os.path.join(base_dir,"..",'tools', 'sqlmap', 'sqlmap.py')
        self.sqlmap_path = self.sqlmap_path.replace('\\', '/')
        self.sqlmap_path = self.sqlmap_path
        self.scan_queue = queue.Queue()
        self.result_queue = queue.Queue()
        self.threads = []
        
        # SQLMap 配置
        self.output_dir = tempfile.mkdtemp(prefix='sqlmap_')
        
        # 輸出路徑信息用於調試
        self.app.logger.info(f"Python 解釋器路徑: {self.python_path}")
        self.app.logger.info(f"SQLMap 腳本路徑: {self.sqlmap_path}")
        self.app.logger.info(f"SQLMap 輸出目錄: {self.output_dir}")
        
        # 驗證 SQLMap 腳本是否存在
        if not os.path.exists(self.sqlmap_path):
            self.app.logger.error(f"SQLMap 腳本未找到: {self.sqlmap_path}")
        else:
            self.app.logger.info("SQLMap 腳本存在")
        
        # FlareSolverr 配置
        self.flaresolverr_url = 'http://localhost:8191/v1'
        
        # 重試配置
        self.max_retries = 3
        self.retry_delay = 1  # 秒
        
        # 數據庫鎖
        self._db_lock = Lock()
        
        # CSRF 相關配置
        self.csrf_patterns = [
            r'name=["\']csrf[_-]token["\'] value=["\'](.*?)["\']',
            r'name=["\']_token["\'] value=["\'](.*?)["\']',
            r'<meta name="csrf-token" content="(.*?)"',
            r'name=["\']_csrf["\'] value=["\'](.*?)["\']'
        ]
        
        # 掃描配置
        self.scan_config = {
            'level': 5,          # 掃描級別 (1-5)
            'risk': 3,           # 風險級別 (1-3)
            'batch': True,       # 使用默認選項
            'random-agent': True,# 隨機 User-Agent
            'threads': 4,        # 線程數
            'timeout': 30,       # 超時時間
            'retries': 3,        # 重試次數
            'dbms': 'mysql',     # 目標數據庫類型
        }

    @contextmanager
    def _db_transaction(self):
        """數據庫事務上下文管理器"""
        with self._db_lock:
            try:
                yield
                db.session.commit()
            except Exception as e:
                db.session.rollback()
                raise e

    def _check_existing_record(self):
        """檢查是否存在相同目標的掃描記錄"""
        for attempt in range(self.max_retries):
            try:
                with self._db_transaction():
                    existing_record = if_sql_injection.query.filter_by(
                        target_id=self.target_id
                    ).with_for_update().first()
                    
                    if existing_record:
                        self.app.logger.info(f"發現目標 ID {self.target_id} 的現有記錄")
                        db.session.delete(existing_record)
                        self.app.logger.info("已刪除現有記錄")
                return True
                
            except OperationalError as e:
                if "database is locked" in str(e) and attempt < self.max_retries - 1:
                    self.app.logger.warning(f"數據庫被鎖定，嘗試重試 ({attempt + 1}/{self.max_retries})")
                    time.sleep(self.retry_delay)
                else:
                    raise
            except Exception as e:
                self.app.logger.error(f"檢查現有記錄時出錯: {str(e)}")
                return False

    def _parse_sqlmap_output(self, output):
        """解析 SQLMap 輸出結果"""
        try:
            vulnerabilities = []
            
            # 解析輸出文本
            if isinstance(output, bytes):
                output = output.decode('utf-8', errors='ignore')
                
            # 檢查是否發現漏洞
            if "SQL injection vulnerability has been detected" in output:
                vuln_details = re.findall(r"Parameter '(.+?)' is vulnerable\. (.+?)(?=\n|$)", output)
                for param, details in vuln_details:
                    vulnerabilities.append({
                        'parameter': param,
                        'details': details.strip(),
                        'type': 'SQL Injection'
                    })
                    
            # 解析數據庫信息
            db_info = {}
            if "Database:" in output:
                db_match = re.search(r"Database: (.+?)(?=\n|$)", output)
                if db_match:
                    db_info['type'] = db_match.group(1)
                    
            # 解析表信息
            tables = []
            if "tables found:" in output:
                tables_section = re.findall(r"tables found:.*?\[(.*?)\]", output, re.DOTALL)
                if tables_section:
                    tables = [t.strip() for t in tables_section[0].split(',')]
                    
            return {
                'vulnerabilities': vulnerabilities,
                'database_info': db_info,
                'tables': tables,
                'raw_output': output
            }
            
        except Exception as e:
            self.app.logger.error(f"解析 SQLMap 輸出時出錯: {str(e)}")
            return None

    def _check_csrf_protection(self, html_content):
        """檢查頁面是否包含CSRF保護"""
        try:
            # 檢查是否存在CSRF相關的標記
            csrf_indicators = [
                'csrf',
                '_token',
                'authenticity_token',
                '_csrf',
                'xsrf'
            ]
            
            html_lower = html_content.lower()
            for indicator in csrf_indicators:
                if indicator in html_lower:
                    self.app.logger.info(f"檢測到CSRF保護標記: {indicator}")
                    return True
                    
            self.app.logger.info("未檢測到CSRF保護")
            return False
            
        except Exception as e:
            self.app.logger.error(f"檢查CSRF保護時出錯: {str(e)}")
            return False

    def _get_csrf_token(self, url):
        """使用分階段方式獲取CSRF令牌"""
        try:
            # 檢查 FlareSolverr 服務是否可用
            try:
                # 使用正確的 FlareSolverr API 調用方式進行健康檢查
                health_check_payload = {
                    "cmd": "request.get",
                    "url": "https://www.google.com",
                    "maxTimeout": 10000
                }
                health_check = requests.post(self.flaresolverr_url, json=health_check_payload, timeout=15)
                if health_check.status_code != 200:
                    self.app.logger.error(f"FlareSolverr 服務返回錯誤狀態碼: {health_check.status_code}")
                    return None
            except requests.exceptions.ConnectionError:
                self.app.logger.error("無法連接到 FlareSolverr 服務")
                return None
            except Exception as e:
                self.app.logger.error(f"FlareSolverr 健康檢查失敗: {str(e)}")
                return None

            # 第一階段：嘗試直接請求
            try:
                response = requests.get(url, timeout=10, verify=False)
                if response.ok:
                    html_content = response.text
                    if not self._check_csrf_protection(html_content):
                        return None
                    
                    for pattern in self.csrf_patterns:
                        match = re.search(pattern, html_content)
                        if match:
                            token = match.group(1)
                            self.app.logger.info("成功通過直接請求獲取CSRF令牌")
                            return token
            except Exception as e:
                self.app.logger.warning(f"直接請求獲取CSRF令牌失敗: {str(e)}")

            # 第二階段：使用FlareSolverr
            self.app.logger.info("嘗試使用FlareSolverr獲取CSRF令牌")
            payload = {
                "cmd": "request.get",
                "url": url,
                "maxTimeout": 60000,
                "headers": {
                    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
                }
            }
            
            try:
                response = requests.post(self.flaresolverr_url, json=payload, timeout=65)
                if response.status_code != 200:
                    self.app.logger.error(f"FlareSolverr 返回錯誤狀態碼: {response.status_code}")
                    return None
                    
                result = response.json()
                if result.get("status") == "ok":
                    html = result.get("solution", {}).get("response")
                    if not html:
                        self.app.logger.error("FlareSolverr 返回的響應中沒有 HTML 內容")
                        return None
                        
                    if not self._check_csrf_protection(html):
                        return None
                    
                    for pattern in self.csrf_patterns:
                        match = re.search(pattern, html)
                        if match:
                            token = match.group(1)
                            self.app.logger.info("成功通過FlareSolverr獲取CSRF令牌")
                            return token
                            
                    self.app.logger.warning("未找到CSRF令牌")
                    return None
                else:
                    self.app.logger.error(f"FlareSolverr請求失敗: {result.get('message')}")
                    return None
            except requests.exceptions.Timeout:
                self.app.logger.error("FlareSolverr 請求超時")
                return None
            except requests.exceptions.RequestException as e:
                self.app.logger.error(f"FlareSolverr 請求失敗: {str(e)}")
                return None
            except Exception as e:
                self.app.logger.error(f"處理 FlareSolverr 響應時出錯: {str(e)}")
                return None
                
        except Exception as e:
            self.app.logger.error(f"獲取CSRF令牌時出錯: {str(e)}")
            return None

    def _get_forms_from_target(self):
        """從目標獲取所有表單信息"""
        try:
            with self._db_transaction():
                # 獲取與目標相關的所有 URL 記錄，但只獲取有表單的 URL
                forms_data = []
                
                # 使用 JOIN 查詢只獲取有表單的 URL
                url_with_forms = db.session.query(crawler_each_url, crawler_each_form).join(
                    crawler_each_form,
                    crawler_each_url.id == crawler_each_form.crawler_each_url_id
                ).filter(
                    crawler_each_url.target_id == self.target_id
                ).all()

                if not url_with_forms:
                    self.app.logger.warning(f"目標 {self.target_id} 沒有找到任何包含表單的 URL")
                    return []

                for url_record, form in url_with_forms:
                    try:
                        form_data = json.loads(form.form)
                        processed_form = {
                            'url': url_record.url,
                            'form_data': form_data,
                            'method': form.form_method or form_data.get('method', 'GET'),
                            'action': form.form_action or form_data.get('action', ''),
                            'inputs': form_data.get('inputs', [])
                        }
                        forms_data.append(processed_form)
                        self.app.logger.info(
                            f"找到表單: URL={url_record.url}, "
                            f"Method={processed_form['method']}, "
                            f"Action={processed_form['action']}, "
                            f"輸入字段數量={len(processed_form['inputs'])}"
                        )
                    except json.JSONDecodeError:
                        self.app.logger.error(f"解析表單數據失敗: {form.form}")
                        continue

                self.app.logger.info(f"總共找到 {len(forms_data)} 個表單需要進行 SQL 注入測試")
                return forms_data

        except Exception as e:
            self.app.logger.error(f"獲取表單數據時出錯: {str(e)}")
            return []

    def _prepare_sqlmap_command(self, url, form=None):
        """準備 SQLMap 掃描命令"""
        try:
            base_cmd = [
                self.python_path,
                self.sqlmap_path,
                '-u', url,
                '--batch',
                '--random-agent',
                '--threads=2',
                '--risk=1',
                '--level=3',
                '--timeout=30',
                '--smart',
                '--technique=BEUSTQ',
                '--tamper=space2comment,between',
                '--time-sec=5',
                '--retries=2',
                '--text-only',
                '--forms'  # 添加此參數以自動檢測表單
            ]

            if form:
                method = form.get('method', 'GET').upper()
                if method == 'POST':
                    # 構建表單數據
                    form_data = {}
                    for input_field in form.get('inputs', []):
                        field_name = input_field.get('name')
                        if field_name:
                            form_data[field_name] = "FUZZ"  # 使用 FUZZ 作為測試值
                    
                    if form_data:
                        data_str = urlencode(form_data)
                        base_cmd.extend(['--data', data_str])
                        base_cmd.append('--chunked')
                    
                    # 添加 cookie 處理
                    base_cmd.extend(['--ignore-code=401,403,404,405'])
                    
                elif method == 'GET':
                    params = []
                    for input_field in form.get('inputs', []):
                        field_name = input_field.get('name')
                        if field_name:
                            params.append(f"{field_name}=*")
                    
                    if params:
                        url_with_params = f"{url}?{'&'.join(params)}"
                        base_cmd[base_cmd.index('-u') + 1] = url_with_params

            # 添加輸出目錄
            output_dir = os.path.join(tempfile.gettempdir(), f'sqlmap_{int(time.time())}')
            os.makedirs(output_dir, exist_ok=True)
            base_cmd.extend(['--output-dir', output_dir])

            self.app.logger.info(f"準備執行 SQLMap 命令: {' '.join(base_cmd)}")
            return base_cmd

        except Exception as e:
            self.app.logger.error(f"準備 SQLMap 命令時出錯: {str(e)}")
            return None

    def _execute_sqlmap_scan(self, cmd, scan_type="一般"):
        """執行 SQLMap 掃描的通用方法"""
        try:
            if not cmd:
                self.app.logger.error("SQLMap 命令為空")
                return None
                
            self.app.logger.info(f"開始執行 {scan_type} SQLMap 掃描")
            self.app.logger.debug(f"完整命令: {' '.join(cmd)}")
            
            # 檢查 SQLMap 腳本是否存在
            if not os.path.exists(self.sqlmap_path):
                self.app.logger.error(f"SQLMap 腳本不存在: {self.sqlmap_path}")
                return None
                
            # 檢查 Python 解釋器
            if not os.path.exists(self.python_path):
                self.app.logger.error(f"Python 解釋器不存在: {self.python_path}")
                return None
            
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                universal_newlines=True,
                cwd=os.path.dirname(self.sqlmap_path)  # 設置工作目錄
            )
            
            stdout, stderr = process.communicate()
            
            # 記錄輸出
            if stdout:
                self.app.logger.debug(f"SQLMap 輸出: {stdout}")
            if stderr:
                self.app.logger.error(f"SQLMap 錯誤: {stderr}")
            
            if process.returncode == 0:
                if "connection timed out" in stdout.lower():
                    self.app.logger.warning("SQLMap 掃描超時")
                    return None
                return self._parse_sqlmap_output(stdout)
            else:
                self.app.logger.error(f"SQLMap 掃描失敗，返回碼: {process.returncode}")
                return None
            
        except subprocess.TimeoutExpired:
            self.app.logger.error("SQLMap 掃描執行超時")
            return None
        except Exception as e:
            self.app.logger.error(f"執行 SQLMap 掃描時出錯: {str(e)}")
            return None

    def _worker(self):
        """工作線程函數"""
        while True:
            try:
                # 從隊列獲取任務
                try:
                    task = self.scan_queue.get(block=True, timeout=1)
                except queue.Empty:
                    break

                if task is None:
                    self.scan_queue.task_done()
                    break

                url, form = task
                self.app.logger.info(f"線程開始掃描 URL: {url}")

                # 準備掃描命令
                cmd = self._prepare_sqlmap_command(url, form)
                if cmd:
                    # 執行掃描
                    result = self._execute_sqlmap_scan(cmd)
                    if result:
                        self.result_queue.put((url, result))
                else:
                    self.app.logger.error(f"為 URL {url} 準備命令失敗")

                # 標記任務完成
                self.scan_queue.task_done()

            except Exception as e:
                self.app.logger.error(f"工作線程執行出錯: {str(e)}")

    def scan(self):
        """執行掃描"""
        try:
            # 在掃描前添加驗證
            if not self.validate_target_url(self.target_url):
                self.app.logger.error(f"無效的目標URL: {self.target_url}")
                return {"status": "error", "message": "無效的目標URL"}

            # 獲取所有表單
            forms = self._get_forms_from_target()
            if not forms:
                self.app.logger.warning("未找到任何表單")
                return {"status": "error", "message": "未找到任何表單"}

            # 將任務添加到隊列
            for form in forms:
                url = form.get('action', self.target_url)
                self.scan_queue.put((url, form))

            # 啟動工作線程
            for _ in range(min(self.num_threads, len(forms))):
                thread = threading.Thread(target=self._worker)
                thread.daemon = True
                thread.start()
                self.threads.append(thread)

            # 等待所有任務完成
            self.scan_queue.join()

            # 收集結果
            results = []
            while not self.result_queue.empty():
                url, result = self.result_queue.get()
                results.append({
                    "url": url,
                    "result": result
                })

            # 保存結果
            if results:
                self._save_scan_result({
                    "scanned_urls": len(results),
                    "vulnerable_urls": len([r for r in results if r["result"].get("is_vulnerable")]),
                    "details": results
                })
                return {
                    "status": "success",
                    "message": "掃描完成",
                    "results": results
                }
            else:
                return {
                    "status": "warning",
                    "message": "掃描完成，未發現漏洞"
                }

        except Exception as e:
            error_msg = f"掃描過程出錯: {str(e)}"
            self.app.logger.error(error_msg)
            return {
                "status": "error",
                "message": error_msg
            }

    def _save_scan_result(self, result_data):
        """保存掃描結果到數據庫"""
        for attempt in range(self.max_retries):
            try:
                with self._db_transaction():
                    scan_result = if_sql_injection(
                        target_id=self.target_id,
                        sql_injection=json.dumps(result_data),  # 使用 sql_injection 而不是 result
                        crawler_each_url_id=1,  # 需要設置一個有效的 URL ID
                        if_sql_injection=bool(result_data.get('vulnerabilities')),  # 根據是否發現漏洞設置
                        scan_time=datetime.now()
                    )
                    db.session.add(scan_result)
                return True
                
            except OperationalError as e:
                if "database is locked" in str(e) and attempt < self.max_retries - 1:
                    self.app.logger.warning(f"數據庫被鎖定，嘗試重試 ({attempt + 1}/{self.max_retries})")
                    time.sleep(self.retry_delay)
                else:
                    raise
            except Exception as e:
                self.app.logger.error(f"保存掃描結果時出錯: {str(e)}")
                return False

    def validate_target_url(self, url):
        try:
            parsed = urlparse(url)
            return bool(parsed.scheme and parsed.netloc)
        except:
            return False

    def analyze_form(self, form, base_url):
        """分析表單數據"""
        try:
            form_data = {
                'method': form.get('method', 'GET').upper(),
                'action': self._normalize_url(form.get('action', ''), base_url),
                'inputs': []
            }
            
            # 處理所有輸入字段
            for input_tag in form.find_all(['input', 'textarea', 'select']):
                input_data = {
                    'name': input_tag.get('name', ''),
                    'type': input_tag.get('type', 'text') if input_tag.name == 'input' else input_tag.name,
                    'required': input_tag.get('required') is not None,
                    'value': input_tag.get('value', ''),
                    'id': input_tag.get('id', ''),
                    'class': ' '.join(input_tag.get('class', [])) if input_tag.get('class') else ''
                }
                
                # 只添加有名稱的輸入字段
                if input_data['name']:
                    form_data['inputs'].append(input_data)
            
            return form_data
        except Exception as e:
            self.app.logger.error(f"分析表單時出錯: {str(e)}")
            return None

    def fetch_js_content(self, js_url):
        """獲取 JavaScript 文件內容"""
        try:
            response = self.send_request_to_flaresolverr(js_url)
            if response and response.get('solution', {}).get('response'):
                js_content = response['solution']['response']
                
                # 基本的 JS 內容驗證
                if 'javascript' in response.get('solution', {}).get('headers', {}).get('content-type', '').lower() or \
                   js_url.lower().endswith('.js'):
                    return js_content.strip()
            return None
        except Exception as e:
            self.app.logger.error(f"獲取 JS 內容時出錯: {str(e)}")
            return None

    def get_crawler_form(self, user_id, target_id):
        """獲取爬蟲表單結果"""
        try:
            # 使用 join 查詢優化
            forms_data = db.session.query(
                crawler_each_url.url,
                crawler_each_form.form,
                crawler_each_form.form_method
            ).join(
                crawler_each_form,
                crawler_each_url.id == crawler_each_form.crawler_each_url_id
            ).filter(
                crawler_each_url.target_id == target_id
            ).all()
            
            if not forms_data:
                return jsonify({
                    'status': 'error',
                    'message': '未找到表單數據'
                }), 404

            processed_forms = []
            for url, form, method in forms_data:
                try:
                    form_data = json.loads(form)
                    processed_forms.append({
                        'url': url,
                        'form': form_data,
                        'method': method
                    })
                except json.JSONDecodeError:
                    continue
            
            return jsonify({
                'status': 'success',
                'data': processed_forms
            })
            
        except Exception as e:
            return jsonify({
                'status': 'error',
                'message': f'獲取表單數據時出錯：{str(e)}'
            }), 500

def setup_logging():
    logger = logging.getLogger(__name__)
    handler = logging.StreamHandler(sys.stdout)
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    handler.setFormatter(formatter)
    handler.stream.reconfigure(encoding='utf-8')
    logger.addHandler(handler)
    logger.setLevel(logging.INFO)
    return logger
